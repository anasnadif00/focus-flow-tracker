# =========================
# Spring / JPA (no DDL sul DB)
# =========================
spring.jpa.open-in-view=false
spring.jpa.hibernate.ddl-auto=none
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Generazione SOLO script SQL su file (Jakarta standard, Hibernate 6)
spring.jpa.properties.jakarta.persistence.schema-generation.scripts.action=create
spring.jpa.properties.jakarta.persistence.schema-generation.scripts.create-target=target/schema.sql
spring.jpa.properties.jakarta.persistence.schema-generation.create-source=metadata
spring.jpa.properties.jakarta.persistence.schema-generation.database.action=none

# (Opzionale) Delimitatore per i comandi SQL
spring.jpa.properties.hibernate.hbm2ddl.delimiter=;

# =========================
# Datasource
# =========================
# In teoria NON serve con la generazione su file, ma alcune versioni provano comunque a connettersi.
# Se ti dà noia, puoi:
# 1) Lasciare i dati Postgres (non verrà toccato nulla)
spring.datasource.url=jdbc:postgresql://localhost:5432/focusflow
spring.datasource.username=focusflow
spring.datasource.password=focusflow

# 2) OPPURE, per generare senza alcun DB vero, usare H2 in memoria (sostituisci le 3 righe sopra con queste):
# spring.datasource.url=jdbc:h2:mem:gen;DB_CLOSE_DELAY=-1
# spring.datasource.username=sa
# spring.datasource.password=

# =========================
# Flyway (off per ora)
# =========================
spring.flyway.enabled=false

# =========================
# Redis / Kafka (non influiscono sulla generazione schema)
# =========================
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.kafka.bootstrap-servers=localhost:9092

# =========================
# Server & altre impostazioni
# =========================
server.port=8080
jwt.secret=changeme
jwt.expiration=3600
